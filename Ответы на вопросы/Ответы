1) ООП (Объектно-ориентированное программирование)
Определение:
Парадигма программирования, основанная на объектах, объединяющих данные (атрибуты) и поведение (методы).

Ключевые принципы:

Инкапсуляция: Сокрытие внутренней реализации (private поля + публичные методы)
Наследование: Создание иерархий классов (Animal → Cat, Dog)
Полиморфизм: Один интерфейс - разные реализации (Shape.area() для Circle и Square)
Абстракция: Работа с концепциями, а не деталями (интерфейс Database для MySQL, PostgreSQL)

Пример:
class BankAccount:
    def __init__(self, balance: float):
        self.__balance = balance  # Инкапсуляция

    def deposit(self, amount: float):  # Публичный интерфейс
        self.__balance += amount

2) Закон Миллера (7 ± 2)
Суть: Человек может одновременно удерживать 5-9 элементов в рабочей памяти.

IT-примеры:

Не более 7 пунктов в меню навигации (GitHub, Google Docs)
Максимум 9 иконок в мобильном BottomBar (Instagram)
Лимит аргументов функции (PEP-8: не более 5)
Глубина вложенности кода (SonarQube: warning при >4)
7±2 микросервисов в одном контексте (DDD)
REST: коллекции ресурсов (/users, /posts), а не 20+ эндпоинтов
Не более 7 вкладок в браузере для комфортной работы
3) Энтропия ПО
Определение: Мера хаоса в коде, ведущая к росту сложности поддержки.

Меры борьбы:
Рефакторинг - устранение "кодового запаха"
Автотесты - pytest для CI/CD
SOLID - разделение интерфейсов (ISP)
Документация - Swagger для API
Стандарты кодирования - PEP-8, ESLint
4) Признаки сложных систем (Гради Буч)
Иерархичность
REST API: Маршрутизатор → Контроллер → Сервис → Репозиторий
Вёрстка: HTML → CSS/Sass → БЭМ-блоки
Обратные связи
Retry-механизм для API-запросов
Автоскейлинг в Kubernetes
Эмерджентность
Сборка Docker-образа (исходники → образ → кластер)
ChatGPT-бот (нейросеть + RAG → осмысленные ответы)
Историческая зависимость
Поддержка legacy-формата CSV
Fallback на REST при недоступности gRPC
Динамическая устойчивость
Балансировщик нагрузки при падении сервера
Механизм повторных запросов (retry) в API
5) Закон Седова в IT-эволюции
Суть: Рост разнообразия на верхнем уровне требует стандартизации на нижнем.

Исторические примеры:

x86-архитектура → Разнообразие устройств (ПК, серверы, IoT)
Байт-код JVM → Kotlin/Scala/Groovy
TCP/IP → HTTP/3, WebSockets, gRPC
UTF-8 → JSON, XML, Protobuf
Виртуализация (KVM) → AWS Lambda, Firebase

Вывод: Каждая революция в IT начиналась с фиксации нижнего уровня (стандарты), что позволяло innovate на верхнем.
